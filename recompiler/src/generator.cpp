/**
 * @file generator.cpp
 * @brief C code generator implementation
 */

#include "recompiler/generator.h"
#include <algorithm>
#include <cctype>
#include <sstream>
#include <fstream>
#include <iomanip>
#include <iostream>
#include <queue>
#include <map>

namespace chip8recomp {

// Forward declarations
static std::string generate_instruction_code(const Instruction& instr,
                                              const GeneratorOptions& options);

static void generate_single_function(const AnalysisResult& analysis,
                                      const uint8_t* rom_data,
                                      size_t rom_size,
                                      const GeneratorOptions& options,
                                      std::ostream& out);

GeneratedOutput generate(const AnalysisResult& analysis,
                         const uint8_t* rom_data,
                         size_t rom_size,
                         const GeneratorOptions& options) {
    GeneratedOutput output;
    
    output.header_file = options.output_prefix + ".h";
    output.source_file = options.output_prefix + ".c";
    output.rom_data_file = "rom_data.c";
    output.main_file = "main.c";
    output.cmake_file = "CMakeLists.txt";
    
    output.main_content = generate_main(options);
    output.cmake_content = generate_cmake(options);
    
    if (options.embed_rom_data) {
        output.rom_data_content = generate_rom_data(rom_data, rom_size, options);
    }
    
    // Generate main source file
    std::ostringstream src;
    
    src << "/**\n";
    src << " * @file " << options.output_prefix << ".c\n";
    src << " * @brief Recompiled CHIP-8 program\n";
    src << " * \n";
    src << " * Auto-generated by chip8recomp - DO NOT EDIT\n";
    src << " */\n\n";
    
    src << "#include \"" << options.output_prefix << ".h\"\n\n";
    
    if (options.single_function_mode) {
        // Single function mode - all code in one function
        generate_single_function(analysis, rom_data, rom_size, options, src);
    } else {
        // Normal mode - separate functions
        for (const auto& [addr, func] : analysis.functions) {
            generate_function(func, analysis, options, src);
            src << "\n";
        }
    }
    
    // Generate function registration (for computed jumps)
    src << "/* Register all functions for computed jump lookup */\n";
    src << "void " << options.output_prefix << "_register_functions(void) {\n";
    if (options.single_function_mode) {
        src << "    chip8_register_function(0x200, " << options.output_prefix << "_main);\n";
    } else {
        for (const auto& [addr, func] : analysis.functions) {
            src << "    chip8_register_function(0x" << std::hex << addr << ", " 
                << func.name << ");\n";
        }
    }
    src << "}\n";
    
    output.source_content = src.str();
    output.header_content = generate_header(analysis, options);
    
    return output;
}

bool write_output(const GeneratedOutput& output,
                  const std::filesystem::path& output_dir) {
    auto write_file = [&output_dir](const std::string& filename, 
                                     const std::string& content) -> bool {
        std::filesystem::path path = output_dir / filename;
        std::ofstream file(path);
        if (!file) {
            std::cerr << "Error: Could not write " << path << "\n";
            return false;
        }
        file << content;
        return true;
    };
    
    if (!write_file(output.header_file, output.header_content)) return false;
    if (!write_file(output.source_file, output.source_content)) return false;
    if (!write_file(output.main_file, output.main_content)) return false;
    if (!write_file(output.cmake_file, output.cmake_content)) return false;
    
    if (!output.rom_data_content.empty()) {
        if (!write_file(output.rom_data_file, output.rom_data_content)) return false;
    }
    
    return true;
}

void generate_instruction(const Instruction& instr,
                          const GeneratorOptions& options,
                          std::ostream& out) {
    // Emit address comment
    if (options.emit_address_comments) {
        out << "    /* 0x" << std::hex << std::uppercase << std::setfill('0')
            << std::setw(3) << instr.address << ": " 
            << std::setw(4) << instr.opcode;
        
        if (options.emit_comments) {
            out << " - " << disassemble(instr).substr(12);  // Skip address part
        }
        
        out << " */\n";
    }
    
    // Emit code
    std::string code = generate_instruction_code(instr, options);
    if (!code.empty()) {
        out << "    " << code << "\n";
    }
}

static std::string generate_instruction_code(const Instruction& instr,
                                              const GeneratorOptions& options) {
    std::ostringstream code;
    
    switch (instr.type) {
        case InstructionType::CLS:
            code << "chip8_clear_screen(ctx);";
            break;
            
        case InstructionType::RET:
            code << "return;";
            break;
            
        case InstructionType::JP:
            // For backward jumps, yield to allow frame processing
            if (instr.nnn <= instr.address) {
                code << "if (--ctx->cycles_remaining <= 0) { ctx->resume_pc = 0x" 
                     << std::hex << instr.nnn << "; ctx->should_yield = true; return; } "
                     << "goto " << generate_label_name(instr.nnn) << ";";
            } else {
                code << "goto " << generate_label_name(instr.nnn) << ";";
            }
            break;
            
        case InstructionType::CALL:
            code << generate_function_name(instr.nnn) << "(ctx);";
            break;
            
        case InstructionType::SE_VX_NN:
            code << "if (ctx->V[0x" << std::hex << (int)instr.x << "] == 0x" 
                 << (int)instr.nn << ") goto " 
                 << generate_label_name(instr.address + 4) << ";";
            break;
            
        case InstructionType::SNE_VX_NN:
            code << "if (ctx->V[0x" << std::hex << (int)instr.x << "] != 0x" 
                 << (int)instr.nn << ") goto " 
                 << generate_label_name(instr.address + 4) << ";";
            break;
            
        case InstructionType::SE_VX_VY:
            code << "if (ctx->V[0x" << std::hex << (int)instr.x << "] == ctx->V[0x" 
                 << (int)instr.y << "]) goto " 
                 << generate_label_name(instr.address + 4) << ";";
            break;
            
        case InstructionType::SNE_VX_VY:
            code << "if (ctx->V[0x" << std::hex << (int)instr.x << "] != ctx->V[0x" 
                 << (int)instr.y << "]) goto " 
                 << generate_label_name(instr.address + 4) << ";";
            break;
            
        case InstructionType::LD_VX_NN:
            code << "ctx->V[0x" << std::hex << (int)instr.x << "] = 0x" 
                 << (int)instr.nn << ";";
            break;
            
        case InstructionType::ADD_VX_NN:
            code << "ctx->V[0x" << std::hex << (int)instr.x << "] += 0x" 
                 << (int)instr.nn << ";";
            break;
            
        case InstructionType::LD_VX_VY:
            code << "ctx->V[0x" << std::hex << (int)instr.x << "] = ctx->V[0x" 
                 << (int)instr.y << "];";
            break;
            
        case InstructionType::OR_VX_VY:
            code << "ctx->V[0x" << std::hex << (int)instr.x << "] |= ctx->V[0x" 
                 << (int)instr.y << "];";
            if (options.quirk_vf_reset) {
                code << " ctx->V[0xF] = 0;";
            }
            break;
            
        case InstructionType::AND_VX_VY:
            code << "ctx->V[0x" << std::hex << (int)instr.x << "] &= ctx->V[0x" 
                 << (int)instr.y << "];";
            if (options.quirk_vf_reset) {
                code << " ctx->V[0xF] = 0;";
            }
            break;
            
        case InstructionType::XOR_VX_VY:
            code << "ctx->V[0x" << std::hex << (int)instr.x << "] ^= ctx->V[0x" 
                 << (int)instr.y << "];";
            if (options.quirk_vf_reset) {
                code << " ctx->V[0xF] = 0;";
            }
            break;
            
        case InstructionType::ADD_VX_VY:
            code << "CHIP8_ADD_VX_VY(ctx, 0x" << std::hex << (int)instr.x 
                 << ", 0x" << (int)instr.y << ");";
            break;
            
        case InstructionType::SUB_VX_VY:
            code << "CHIP8_SUB_VX_VY(ctx, 0x" << std::hex << (int)instr.x 
                 << ", 0x" << (int)instr.y << ");";
            break;
            
        case InstructionType::SHR_VX:
            if (options.quirk_shift_uses_vy) {
                code << "CHIP8_SHR_VX_VY(ctx, 0x" << std::hex << (int)instr.x 
                     << ", 0x" << (int)instr.y << ");";
            } else {
                code << "CHIP8_SHR_VX(ctx, 0x" << std::hex << (int)instr.x << ");";
            }
            break;
            
        case InstructionType::SUBN_VX_VY:
            code << "CHIP8_SUBN_VX_VY(ctx, 0x" << std::hex << (int)instr.x 
                 << ", 0x" << (int)instr.y << ");";
            break;
            
        case InstructionType::SHL_VX:
            if (options.quirk_shift_uses_vy) {
                code << "CHIP8_SHL_VX_VY(ctx, 0x" << std::hex << (int)instr.x 
                     << ", 0x" << (int)instr.y << ");";
            } else {
                code << "CHIP8_SHL_VX(ctx, 0x" << std::hex << (int)instr.x << ");";
            }
            break;
            
        case InstructionType::LD_I_NNN:
            code << "ctx->I = 0x" << std::hex << instr.nnn << ";";
            break;
            
        case InstructionType::JP_V0:
            code << "CHIP8_COMPUTED_JUMP(ctx, 0x" << std::hex << instr.nnn << ");";
            break;
            
        case InstructionType::RND:
            code << "ctx->V[0x" << std::hex << (int)instr.x 
                 << "] = chip8_random_byte() & 0x" << (int)instr.nn << ";";
            break;
            
        case InstructionType::DRW:
            code << "chip8_draw_sprite(ctx, 0x" << std::hex << (int)instr.x 
                 << ", 0x" << (int)instr.y << ", " << std::dec << (int)instr.n << "); "
                 << "--ctx->cycles_remaining;";
            break;
            
        case InstructionType::SKP:
            code << "if (chip8_key_pressed(ctx, ctx->V[0x" << std::hex 
                 << (int)instr.x << "])) goto " 
                 << generate_label_name(instr.address + 4) << ";";
            break;
            
        case InstructionType::SKNP:
            code << "if (!chip8_key_pressed(ctx, ctx->V[0x" << std::hex 
                 << (int)instr.x << "])) goto " 
                 << generate_label_name(instr.address + 4) << ";";
            break;
            
        case InstructionType::LD_VX_DT:
            code << "ctx->V[0x" << std::hex << (int)instr.x << "] = ctx->delay_timer;";
            break;
            
        case InstructionType::LD_VX_K:
            code << "chip8_wait_key(ctx, 0x" << std::hex << (int)instr.x << ");";
            break;
            
        case InstructionType::LD_DT_VX:
            code << "ctx->delay_timer = ctx->V[0x" << std::hex << (int)instr.x << "];";
            break;
            
        case InstructionType::LD_ST_VX:
            code << "ctx->sound_timer = ctx->V[0x" << std::hex << (int)instr.x << "];";
            break;
            
        case InstructionType::ADD_I_VX:
            code << "ctx->I += ctx->V[0x" << std::hex << (int)instr.x << "];";
            break;
            
        case InstructionType::LD_F_VX:
            code << "ctx->I = CHIP8_FONT_START + ctx->V[0x" << std::hex 
                 << (int)instr.x << "] * 5;";
            break;
            
        case InstructionType::LD_B_VX:
            code << "chip8_store_bcd(ctx, 0x" << std::hex << (int)instr.x << ");";
            break;
            
        case InstructionType::LD_I_VX:
            code << "chip8_store_registers(ctx, 0x" << std::hex << (int)instr.x 
                 << ", " << (options.quirk_load_store_inc_i ? "true" : "false") << ");";
            break;
            
        case InstructionType::LD_VX_I:
            code << "chip8_load_registers(ctx, 0x" << std::hex << (int)instr.x 
                 << ", " << (options.quirk_load_store_inc_i ? "true" : "false") << ");";
            break;
            
        case InstructionType::SYS:
            code << "/* SYS 0x" << std::hex << instr.nnn << " - ignored */";
            break;
            
        case InstructionType::UNKNOWN:
            code << "/* UNKNOWN opcode 0x" << std::hex << instr.opcode << " */";
            break;
    }
    
    return code.str();
}

void generate_block(const BasicBlock& block,
                    const std::vector<Instruction>& instructions,
                    const AnalysisResult& analysis,
                    const GeneratorOptions& options,
                    std::ostream& out) {
    // Emit label if needed
    if (analysis.label_addresses.count(block.start_address)) {
        out << generate_label_name(block.start_address) << ":\n";
    }
    
    // Emit each instruction
    for (size_t idx : block.instruction_indices) {
        const auto& instr = instructions[idx];
        
        // Check if we need an internal label
        if (block.internal_labels.count(instr.address) && 
            instr.address != block.start_address) {
            out << generate_label_name(instr.address) << ":\n";
        }
        
        generate_instruction(instr, options, out);
    }
}

void generate_function(const Function& func,
                       const AnalysisResult& analysis,
                       const GeneratorOptions& options,
                       std::ostream& out) {
    out << "void " << func.name << "(Chip8Context* ctx) {\n";
    
    // Collect all backward jump targets within THIS function
    std::set<uint16_t> backward_jump_targets;
    std::set<uint16_t> func_addresses;
    
    // First, get all addresses that belong to this function
    for (uint16_t block_addr : func.block_addresses) {
        if (!analysis.blocks.count(block_addr)) continue;
        const auto& block = analysis.blocks.at(block_addr);
        for (size_t idx : block.instruction_indices) {
            func_addresses.insert(analysis.instructions[idx].address);
        }
    }
    
    // Now find backward jumps within this function
    for (uint16_t block_addr : func.block_addresses) {
        if (!analysis.blocks.count(block_addr)) continue;
        const auto& block = analysis.blocks.at(block_addr);
        for (size_t idx : block.instruction_indices) {
            const auto& instr = analysis.instructions[idx];
            if (instr.type == InstructionType::JP && instr.nnn <= instr.address) {
                // Only add if the target is within this function
                if (func_addresses.count(instr.nnn)) {
                    backward_jump_targets.insert(instr.nnn);
                }
            }
        }
    }
    
    // Emit resume check at function start if there are backward jumps
    if (!backward_jump_targets.empty()) {
        out << "    /* Resume from yield if needed */\n";
        out << "    if (ctx->should_yield) {\n";
        out << "        ctx->should_yield = false;\n";
        for (uint16_t target : backward_jump_targets) {
            out << "        if (ctx->resume_pc == 0x" << std::hex << target << ") goto " 
                << generate_label_name(target) << ";\n";
        }
        out << "    }\n\n";
    }
    
    // Sort blocks by address
    std::vector<uint16_t> sorted_addrs = func.block_addresses;
    std::sort(sorted_addrs.begin(), sorted_addrs.end());
    
    for (uint16_t addr : sorted_addrs) {
        if (!analysis.blocks.count(addr)) continue;
        
        const auto& block = analysis.blocks.at(addr);
        generate_block(block, analysis.instructions, analysis, options, out);
    }
    
    out << "}\n";
}

void generate_single_function(const AnalysisResult& analysis,
                               const uint8_t* rom_data,
                               size_t rom_size,
                               const GeneratorOptions& options,
                               std::ostream& out) {
    out << "void " << options.output_prefix << "_main(Chip8Context* ctx) {\n";
    
    const uint16_t base_address = 0x200;
    
    // Helper lambda to decode an instruction at any address (even or odd)
    auto decode_at = [&](uint16_t addr) -> Instruction {
        if (addr < base_address) {
            Instruction instr{};
            instr.address = addr;
            instr.type = InstructionType::UNKNOWN;
            return instr;
        }
        
        size_t offset = addr - base_address;
        if (offset + 1 >= rom_size) {
            Instruction instr{};
            instr.address = addr;
            instr.type = InstructionType::UNKNOWN;
            return instr;
        }
        
        uint16_t opcode = (static_cast<uint16_t>(rom_data[offset]) << 8) | rom_data[offset + 1];
        return decode_opcode(opcode, addr);
    };
    
    // === PASS 1: Reachability analysis with on-the-fly decoding ===
    std::map<uint16_t, Instruction> decoded_instrs;
    std::set<uint16_t> reachable;
    std::queue<uint16_t> worklist;
    worklist.push(analysis.entry_point);
    
    while (!worklist.empty()) {
        uint16_t addr = worklist.front();
        worklist.pop();
        
        if (reachable.count(addr)) continue;
        if (addr < base_address || (addr - base_address) + 1 >= rom_size) continue;
        
        // Decode on-the-fly
        Instruction instr = decode_at(addr);
        
        // Skip data sections
        if (instr.type == InstructionType::UNKNOWN) continue;
        if (instr.type == InstructionType::SYS && instr.opcode != 0x00E0 && instr.opcode != 0x00EE) continue;
        
        reachable.insert(addr);
        decoded_instrs[addr] = instr;
        
        // Determine successors
        switch (instr.type) {
            case InstructionType::JP:
                worklist.push(instr.nnn);
                break;
                
            case InstructionType::CALL:
                worklist.push(instr.nnn);  // Called function
                worklist.push(addr + 2);   // Return address
                break;
                
            case InstructionType::RET:
                // No static successors
                break;
                
            case InstructionType::JP_V0:
                // Computed jump - try to cover a range
                for (uint16_t offset = 0; offset < 32; offset += 2) {
                    if ((instr.nnn + offset) >= base_address) {
                        worklist.push(instr.nnn + offset);
                    }
                }
                break;
                
            case InstructionType::SE_VX_NN:
            case InstructionType::SNE_VX_NN:
            case InstructionType::SE_VX_VY:
            case InstructionType::SNE_VX_VY:
            case InstructionType::SKP:
            case InstructionType::SKNP:
                // Skip instructions: both paths
                worklist.push(addr + 2);  // Not skipped
                worklist.push(addr + 4);  // Skipped
                break;
                
            default:
                // Sequential instruction
                worklist.push(addr + 2);
                break;
        }
    }
    
    // === PASS 2: Collect metadata from reachable instructions ===
    std::set<uint16_t> backward_jump_targets;
    std::set<uint16_t> return_addresses;
    std::set<uint16_t> needed_labels;
    
    for (const auto& [addr, instr] : decoded_instrs) {
        // Backward jump targets need yield support
        if (instr.type == InstructionType::JP && instr.nnn <= addr) {
            backward_jump_targets.insert(instr.nnn);
        }
        
        // Collect return addresses for CALL dispatch
        if (instr.type == InstructionType::CALL) {
            return_addresses.insert(addr + 2);
        }
        
        // Collect all needed labels
        switch (instr.type) {
            case InstructionType::JP:
                needed_labels.insert(instr.nnn);
                break;
            case InstructionType::CALL:
                needed_labels.insert(instr.nnn);
                needed_labels.insert(addr + 2);  // Return point
                break;
            case InstructionType::SE_VX_NN:
            case InstructionType::SNE_VX_NN:
            case InstructionType::SE_VX_VY:
            case InstructionType::SNE_VX_VY:
            case InstructionType::SKP:
            case InstructionType::SKNP:
                needed_labels.insert(addr + 2);
                needed_labels.insert(addr + 4);
                break;
            default:
                break;
        }
    }
    
    // === PASS 3: Emit code ===
    
    // Emit resume check for backward jumps
    if (!backward_jump_targets.empty()) {
        out << "    /* Resume from yield if needed */\n";
        out << "    if (ctx->should_yield) {\n";
        out << "        ctx->should_yield = false;\n";
        for (uint16_t target : backward_jump_targets) {
            out << "        if (ctx->resume_pc == 0x" << std::hex << target << ") goto " 
                << generate_label_name(target) << ";\n";
        }
        out << "    }\n\n";
    }
    
    // Get sorted list of reachable addresses
    std::vector<uint16_t> sorted_addrs(reachable.begin(), reachable.end());
    std::sort(sorted_addrs.begin(), sorted_addrs.end());
    
    std::set<uint16_t> emitted_labels;
    
    for (uint16_t addr : sorted_addrs) {
        const Instruction& instr = decoded_instrs[addr];
        
        // Emit label if needed
        if (needed_labels.count(addr) && !emitted_labels.count(addr)) {
            out << generate_label_name(addr) << ":\n";
            emitted_labels.insert(addr);
        }
        
        // Special handling for CALL and RET in single-function mode
        if (instr.type == InstructionType::CALL) {
            out << "    /* CALL 0x" << std::hex << instr.nnn << " at 0x" 
                << addr << " */\n";
            out << "    ctx->stack[ctx->SP++] = 0x" << std::hex << (addr + 2) << ";\n";
            out << "    goto " << generate_label_name(instr.nnn) << ";\n";
        } else if (instr.type == InstructionType::RET) {
            out << "    /* RET - dispatch based on return address */\n";
            out << "    {\n";
            out << "        uint16_t ret_addr = ctx->stack[--ctx->SP];\n";
            out << "        switch (ret_addr) {\n";
            for (uint16_t ret_addr : return_addresses) {
                out << "            case 0x" << std::hex << ret_addr << ": goto " 
                    << generate_label_name(ret_addr) << ";\n";
            }
            out << "            default: return; /* Unknown return address */\n";
            out << "        }\n";
            out << "    }\n";
        } else {
            // Normal instruction handling
            generate_instruction(instr, options, out);
        }
    }
    
    out << "}\n";
}

std::string generate_header(const AnalysisResult& analysis,
                            const GeneratorOptions& options) {
    std::ostringstream hdr;
    
    std::string guard = options.output_prefix + "_H";
    std::transform(guard.begin(), guard.end(), guard.begin(), ::toupper);
    
    hdr << "/**\n";
    hdr << " * @file " << options.output_prefix << ".h\n";
    hdr << " * @brief Recompiled CHIP-8 program header\n";
    hdr << " * \n";
    hdr << " * Auto-generated by chip8recomp - DO NOT EDIT\n";
    hdr << " */\n\n";
    
    hdr << "#ifndef " << guard << "\n";
    hdr << "#define " << guard << "\n\n";
    
    hdr << "#include <chip8rt/runtime.h>\n\n";
    
    hdr << "#ifdef __cplusplus\n";
    hdr << "extern \"C\" {\n";
    hdr << "#endif\n\n";
    
    hdr << "/* Function declarations */\n";
    if (options.single_function_mode) {
        hdr << "void " << options.output_prefix << "_main(Chip8Context* ctx);\n";
    } else {
        for (const auto& [addr, func] : analysis.functions) {
            hdr << "void " << func.name << "(Chip8Context* ctx);\n";
        }
    }
    hdr << "\n";
    
    hdr << "/* Register all functions for computed jump lookup */\n";
    hdr << "void " << options.output_prefix << "_register_functions(void);\n\n";
    
    hdr << "/* Entry point */\n";
    if (options.single_function_mode) {
        hdr << "#define " << options.output_prefix << "_entry " 
            << options.output_prefix << "_main\n\n";
    } else {
        hdr << "#define " << options.output_prefix << "_entry " 
            << generate_function_name(analysis.entry_point) << "\n\n";
    }
    
    hdr << "#ifdef __cplusplus\n";
    hdr << "}\n";
    hdr << "#endif\n\n";
    
    hdr << "#endif /* " << guard << " */\n";
    
    return hdr.str();
}

std::string generate_main(const GeneratorOptions& options) {
    std::ostringstream main;
    
    main << "/**\n";
    main << " * @file main.c\n";
    main << " * @brief Entry point for recompiled CHIP-8 program\n";
    main << " * \n";
    main << " * Auto-generated by chip8recomp - DO NOT EDIT\n";
    main << " */\n\n";
    
    main << "#include \"" << options.output_prefix << ".h\"\n";
    main << "#include <chip8rt/platform.h>\n\n";
    
    if (options.embed_rom_data) {
        main << "/* Embedded ROM data (for sprites, etc.) */\n";
        main << "extern const uint8_t rom_data[];\n";
        main << "extern const size_t rom_data_size;\n\n";
    }
    
    main << "int main(int argc, char* argv[]) {\n";
    main << "    (void)argc; (void)argv;\n\n";
    
    main << "    /* Set up platform */\n";
    main << "    chip8_set_platform(chip8_platform_sdl2());\n\n";
    
    main << "    /* Register recompiled functions */\n";
    main << "    " << options.output_prefix << "_register_functions();\n\n";
    
    main << "    /* Run configuration */\n";
    main << "    Chip8RunConfig config = CHIP8_RUN_CONFIG_DEFAULT;\n";
    main << "    config.title = \"" << options.output_prefix << "\";\n";
    main << "    config.scale = 10;\n";
    main << "    config.cpu_freq_hz = 300;  /* Reasonable speed for most games */\n";
    
    if (options.embed_rom_data) {
        main << "    config.rom_data = rom_data;\n";
        main << "    config.rom_size = rom_data_size;\n";
    }
    
    main << "\n";
    main << "    /* Run the recompiled program */\n";
    main << "    return chip8_run(" << options.output_prefix << "_entry, &config);\n";
    main << "}\n";
    
    return main.str();
}

std::string generate_cmake(const GeneratorOptions& options) {
    std::ostringstream cmake;
    
    cmake << "# Auto-generated CMakeLists.txt for " << options.output_prefix << "\n";
    cmake << "# Generated by chip8recomp\n\n";
    
    cmake << "cmake_minimum_required(VERSION 3.20)\n";
    cmake << "project(" << options.output_prefix << " LANGUAGES C CXX)\n\n";
    
    cmake << "set(CMAKE_C_STANDARD 11)\n";
    cmake << "set(CMAKE_CXX_STANDARD 17)\n\n";
    
    cmake << "# Find SDL2\n";
    cmake << "find_package(SDL2 REQUIRED)\n\n";
    
    cmake << "# Path to the chip8-recompiled source tree\n";
    cmake << "# Adjust this path based on where the generated project is relative to chip8-recompiled\n";
    cmake << "set(CHIP8_RECOMPILED_DIR \"${CMAKE_CURRENT_SOURCE_DIR}/../..\" CACHE PATH \"Path to chip8-recompiled\")\n";
    cmake << "set(IMGUI_DIR \"${CHIP8_RECOMPILED_DIR}/external/imgui\")\n\n";
    
    cmake << "# Include runtime headers\n";
    cmake << "include_directories(\n";
    cmake << "    ${CHIP8_RECOMPILED_DIR}/runtime/include\n";
    cmake << "    ${IMGUI_DIR}\n";
    cmake << "    ${IMGUI_DIR}/backends\n";
    cmake << ")\n\n";
    
    cmake << "# Sources\n";
    cmake << "set(SOURCES\n";
    cmake << "    main.c\n";
    cmake << "    " << options.output_prefix << ".c\n";
    if (options.embed_rom_data) {
        cmake << "    rom_data.c\n";
    }
    cmake << ")\n\n";
    
    cmake << "# Runtime sources (compiled directly)\n";
    cmake << "set(RUNTIME_SOURCES\n";
    cmake << "    ${CHIP8_RECOMPILED_DIR}/runtime/src/context.c\n";
    cmake << "    ${CHIP8_RECOMPILED_DIR}/runtime/src/instructions.c\n";
    cmake << "    ${CHIP8_RECOMPILED_DIR}/runtime/src/runtime.c\n";
    cmake << "    ${CHIP8_RECOMPILED_DIR}/runtime/src/platform_sdl.c\n";
    cmake << "    ${CHIP8_RECOMPILED_DIR}/runtime/src/font.c\n";
    cmake << "    ${CHIP8_RECOMPILED_DIR}/runtime/src/settings.c\n";
    cmake << "    ${CHIP8_RECOMPILED_DIR}/runtime/src/menu.c\n";
    cmake << "    ${CHIP8_RECOMPILED_DIR}/runtime/src/imgui_overlay.cpp\n";
    cmake << ")\n\n";
    
    cmake << "# ImGui sources\n";
    cmake << "set(IMGUI_SOURCES\n";
    cmake << "    ${IMGUI_DIR}/imgui.cpp\n";
    cmake << "    ${IMGUI_DIR}/imgui_demo.cpp\n";
    cmake << "    ${IMGUI_DIR}/imgui_draw.cpp\n";
    cmake << "    ${IMGUI_DIR}/imgui_tables.cpp\n";
    cmake << "    ${IMGUI_DIR}/imgui_widgets.cpp\n";
    cmake << "    ${IMGUI_DIR}/backends/imgui_impl_sdl2.cpp\n";
    cmake << "    ${IMGUI_DIR}/backends/imgui_impl_sdlrenderer2.cpp\n";
    cmake << ")\n\n";
    
    cmake << "# Create executable\n";
    cmake << "add_executable(" << options.output_prefix << " ${SOURCES} ${RUNTIME_SOURCES} ${IMGUI_SOURCES})\n\n";
    
    cmake << "# Link SDL2\n";
    cmake << "target_link_libraries(" << options.output_prefix << " PRIVATE SDL2::SDL2)\n\n";
    
    cmake << "# Platform-specific definitions\n";
    cmake << "if(APPLE)\n";
    cmake << "    target_compile_definitions(" << options.output_prefix << " PRIVATE CHIP8_PLATFORM_MACOS)\n";
    cmake << "endif()\n";
    
    return cmake.str();
}

std::string generate_rom_data(const uint8_t* rom_data,
                               size_t rom_size,
                               const GeneratorOptions& options) {
    std::ostringstream out;
    
    out << "/**\n";
    out << " * @file rom_data.c\n";
    out << " * @brief Embedded ROM data for " << options.output_prefix << "\n";
    out << " * \n";
    out << " * Auto-generated by chip8recomp - DO NOT EDIT\n";
    out << " */\n\n";
    
    out << "#include <stdint.h>\n";
    out << "#include <stddef.h>\n\n";
    
    out << "const uint8_t rom_data[] = {\n";
    
    for (size_t i = 0; i < rom_size; ++i) {
        if (i % 16 == 0) {
            out << "    ";
        }
        
        out << "0x" << std::hex << std::uppercase << std::setfill('0') 
            << std::setw(2) << (int)rom_data[i];
        
        if (i < rom_size - 1) {
            out << ", ";
        }
        
        if (i % 16 == 15 || i == rom_size - 1) {
            out << "\n";
        }
    }
    
    out << "};\n\n";
    
    out << "const size_t rom_data_size = " << std::dec << rom_size << ";\n";
    
    return out.str();
}

} // namespace chip8recomp
