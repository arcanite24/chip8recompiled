/**
 * @file batch.cpp
 * @brief Batch recompilation implementation
 */

#include "recompiler/batch.h"
#include "recompiler/rom.h"
#include "recompiler/decoder.h"
#include "recompiler/analyzer.h"
#include "recompiler/generator.h"

#include <iostream>
#include <fstream>
#include <sstream>
#include <algorithm>
#include <map>

namespace fs = std::filesystem;

namespace chip8recomp {

// Helper: Load metadata from JSON (simplified - could use a JSON library)
static std::map<std::string, RomMetadata> load_metadata(const fs::path& metadata_file) {
    std::map<std::string, RomMetadata> metadata;
    
    // For now, return empty map
    // TODO: Implement JSON parsing if metadata file provided
    
    return metadata;
}

// Helper: Generate ROM catalog C code
static std::string generate_rom_catalog(
    const std::vector<std::pair<std::string, RomMetadata>>& roms) {
    
    std::ostringstream out;
    
    out << "/**\n";
    out << " * @file rom_catalog.c\n";
    out << " * @brief Multi-ROM catalog - Auto-generated\n";
    out << " */\n\n";
    
    out << "#include <chip8rt/rom_catalog.h>\n\n";
    
    // Include ROM headers to get _entry macros
    for (const auto& [name, meta] : roms) {
        out << "#include \"" << name << ".h\"\n";
    }
    out << "\n";
    
    // External declarations for ROM data (functions are in headers)
    for (const auto& [name, meta] : roms) {
        out << "/* " << meta.title << " */\n";
        out << "extern const uint8_t " << name << "_rom_data[];\n";
        out << "extern const size_t " << name << "_rom_data_size;\n\n";
    }
    
    // Catalog array
    out << "const RomEntry rom_catalog[] = {\n";
    for (const auto& [name, meta] : roms) {
        out << "    {\n";
        out << "        .name = \"" << name << "\",\n";
        out << "        .title = \"" << meta.title << "\",\n";
        out << "        .data = " << name << "_rom_data,\n";
        out << "        .size = " << meta.rom_size << ",\n";
        out << "        .entry = " << name << "_entry,\n";
        out << "        .register_functions = " << name << "_register_functions,\n";
        out << "        .recommended_cpu_freq = " << meta.recommended_cpu_freq << ",\n";
        
        if (!meta.description.empty()) {
            out << "        .description = \"" << meta.description << "\",\n";
        } else {
            out << "        .description = NULL,\n";
        }
        
        if (!meta.authors.empty()) {
            out << "        .authors = \"" << meta.authors << "\",\n";
        } else {
            out << "        .authors = NULL,\n";
        }
        
        if (!meta.release.empty()) {
            out << "        .release = \"" << meta.release << "\"\n";
        } else {
            out << "        .release = NULL\n";
        }
        
        out << "    },\n";
    }
    out << "};\n\n";
    
    out << "const size_t rom_catalog_count = " << roms.size() << ";\n";
    
    return out.str();
}

// Helper: Generate multi-ROM main.c
static std::string generate_multi_rom_main() {
    std::ostringstream out;
    
    out << "/**\n";
    out << " * @file main.c\n";
    out << " * @brief Multi-ROM launcher entry point\n";
    out << " */\n\n";
    
    out << "#include <chip8rt/rom_catalog.h>\n";
    out << "#include <chip8rt/platform.h>\n";
    out << "#include <chip8rt/menu.h>\n";
    out << "#include <stdlib.h>\n\n";
    
    out << "extern const RomEntry rom_catalog[];\n";
    out << "extern const size_t rom_catalog_count;\n\n";
    
    out << "int main(int argc, char* argv[]) {\n";
    out << "    /* Set platform to SDL2 */\n";
    out << "    chip8_set_platform(chip8_platform_sdl2());\n\n";
    
    out << "    /* Enable multi-ROM menu mode */\n";
    out << "    chip8_menu_set_multi_rom_mode(true);\n\n";
    
    out << "    /* Run multi-ROM launcher */\n";
    out << "    return chip8_run_with_menu(rom_catalog, rom_catalog_count);\n";
    out << "}\n";
    
    return out.str();
}

// Helper: Generate CMakeLists.txt for multi-ROM build
static std::string generate_multi_rom_cmake(
    const std::vector<std::pair<std::string, RomMetadata>>& roms) {
    
    std::ostringstream out;
    
    out << "# Multi-ROM launcher CMakeLists.txt\n";
    out << "# Auto-generated by chip8recomp\n\n";
    
    out << "cmake_minimum_required(VERSION 3.20)\n";
    out << "project(chip8_multi_rom LANGUAGES C CXX)\n\n";
    
    out << "set(CMAKE_C_STANDARD 11)\n";
    out << "set(CMAKE_CXX_STANDARD 17)\n\n";
    
    out << "# Find SDL2\n";
    out << "find_package(SDL2 REQUIRED)\n\n";
    
    out << "# Path to chip8-recompiled\n";
    out << "set(CHIP8_RECOMPILED_DIR \"${CMAKE_CURRENT_SOURCE_DIR}/../..\" ";
    out << "CACHE PATH \"Path to chip8-recompiled\")\n";
    out << "set(IMGUI_DIR \"${CHIP8_RECOMPILED_DIR}/external/imgui\")\n\n";
    
    out << "# Include directories\n";
    out << "include_directories(\n";
    out << "    ${CHIP8_RECOMPILED_DIR}/runtime/include\n";
    out << "    ${IMGUI_DIR}\n";
    out << "    ${IMGUI_DIR}/backends\n";
    out << ")\n\n";
    
    out << "# ROM sources\n";
    out << "set(ROM_SOURCES\n";
    for (const auto& [name, meta] : roms) {
        out << "    " << name << ".c\n";
        out << "    " << name << "_rom_data.c\n";
    }
    out << ")\n\n";
    
    out << "# Main sources\n";
    out << "set(MAIN_SOURCES\n";
    out << "    main.c\n";
    out << "    rom_catalog.c\n";
    out << ")\n\n";
    
    out << "# Runtime sources\n";
    out << "set(RUNTIME_SOURCES\n";
    out << "    ${CHIP8_RECOMPILED_DIR}/runtime/src/context.c\n";
    out << "    ${CHIP8_RECOMPILED_DIR}/runtime/src/instructions.c\n";
    out << "    ${CHIP8_RECOMPILED_DIR}/runtime/src/runtime.c\n";
    out << "    ${CHIP8_RECOMPILED_DIR}/runtime/src/platform_sdl.c\n";
    out << "    ${CHIP8_RECOMPILED_DIR}/runtime/src/platform_headless.c\n";
    out << "    ${CHIP8_RECOMPILED_DIR}/runtime/src/font.c\n";
    out << "    ${CHIP8_RECOMPILED_DIR}/runtime/src/settings.c\n";
    out << "    ${CHIP8_RECOMPILED_DIR}/runtime/src/menu.c\n";
    out << "    ${CHIP8_RECOMPILED_DIR}/runtime/src/imgui_overlay.cpp\n";
    out << "    ${CHIP8_RECOMPILED_DIR}/runtime/src/rom_selector.cpp\n";
    out << ")\n\n";
    
    out << "# ImGui sources\n";
    out << "set(IMGUI_SOURCES\n";
    out << "    ${IMGUI_DIR}/imgui.cpp\n";
    out << "    ${IMGUI_DIR}/imgui_demo.cpp\n";
    out << "    ${IMGUI_DIR}/imgui_draw.cpp\n";
    out << "    ${IMGUI_DIR}/imgui_tables.cpp\n";
    out << "    ${IMGUI_DIR}/imgui_widgets.cpp\n";
    out << "    ${IMGUI_DIR}/backends/imgui_impl_sdl2.cpp\n";
    out << "    ${IMGUI_DIR}/backends/imgui_impl_sdlrenderer2.cpp\n";
    out << ")\n\n";
    
    out << "# Create executable\n";
    out << "add_executable(chip8_launcher\n";
    out << "    ${MAIN_SOURCES}\n";
    out << "    ${ROM_SOURCES}\n";
    out << "    ${RUNTIME_SOURCES}\n";
    out << "    ${IMGUI_SOURCES}\n";
    out << ")\n\n";
    
    out << "# Link SDL2\n";
    out << "target_link_libraries(chip8_launcher PRIVATE SDL2::SDL2)\n\n";
    
    out << "# Platform-specific definitions\n";
    out << "if(APPLE)\n";
    out << "    target_compile_definitions(chip8_launcher PRIVATE CHIP8_PLATFORM_MACOS)\n";
    out << "endif()\n";
    
    return out.str();
}

int compile_batch(const BatchOptions& options) {
    std::cout << "Batch recompilation mode\n";
    std::cout << "ROM directory: " << options.rom_dir << "\n";
    std::cout << "Output directory: " << options.output_dir << "\n\n";
    
    // Find all ROM files
    std::vector<fs::path> rom_files;
    for (const auto& entry : fs::directory_iterator(options.rom_dir)) {
        if (entry.is_regular_file()) {
            auto ext = entry.path().extension().string();
            std::transform(ext.begin(), ext.end(), ext.begin(), ::tolower);
            if (ext == ".ch8" || ext == ".chip8") {
                rom_files.push_back(entry.path());
            }
        }
    }
    
    if (rom_files.empty()) {
        std::cerr << "Error: No ROM files found in " << options.rom_dir << "\n";
        return 1;
    }
    
    std::cout << "Found " << rom_files.size() << " ROM(s)\n\n";
    
    // Load metadata if provided
    std::map<std::string, RomMetadata> metadata_map;
    if (!options.metadata_file.empty()) {
        metadata_map = load_metadata(options.metadata_file);
    }
    
    // Sort ROM files by name for consistent ordering
    std::sort(rom_files.begin(), rom_files.end());
    
    // Create output directory
    if (!fs::exists(options.output_dir)) {
        fs::create_directories(options.output_dir);
    }
    
    // Compile each ROM
    std::vector<std::pair<std::string, RomMetadata>> compiled_roms;
    
    for (const auto& rom_path : rom_files) {
        std::string rom_name = extract_rom_name(rom_path.string());
        std::cout << "Compiling: " << rom_name << " (" << rom_path.filename() << ")\n";
        
        // Load ROM
        auto rom = load_rom(rom_path.string());
        if (!rom) {
            std::cerr << "  Error: Failed to load ROM\n";
            continue;
        }
        
        std::string error_msg;
        if (!validate_rom(*rom, error_msg)) {
            std::cerr << "  Error: Invalid ROM: " << error_msg << "\n";
            continue;
        }
        
        // Decode
        auto instructions = decode_rom(rom->bytes(), rom->size());
        
        // Analyze
        auto analysis = analyze(instructions);
        
        // Get metadata or create default
        RomMetadata meta;
        if (metadata_map.count(rom_name)) {
            meta = metadata_map[rom_name];
        } else {
            meta.name = rom_name;
            meta.title = rom_path.stem().string();
        }
        meta.rom_size = rom->size();  // Store the ROM size

        // Generate code
        GeneratorOptions gen_opts = options.gen_opts;
        gen_opts.output_prefix = rom_name;
        gen_opts.output_dir = options.output_dir;
        gen_opts.embed_rom_data = true;
        gen_opts.use_prefixed_symbols = true;  // Use prefixed symbols for batch mode
        
        // In batch mode, always use single-function mode for reliability
        // This avoids issues with inter-function jumps (like jumping to 0x200 from subroutines)
        bool use_single_function = true;
        if (!gen_opts.single_function_mode && options.auto_mode) {
            // ROMs with computed jumps need single-function mode anyway
            if (!analysis.computed_jump_bases.empty()) {
                std::cout << "  (auto: using single-function mode - has computed jumps)\n";
            }
        }
        gen_opts.single_function_mode = use_single_function;
        
        auto output = generate(analysis, rom->bytes(), rom->size(), gen_opts);
        
        // Rename output files with ROM prefix
        output.header_file = rom_name + ".h";
        output.source_file = rom_name + ".c";
        output.rom_data_file = rom_name + "_rom_data.c";
        // Don't write individual main.c or CMakeLists.txt
        
        // Write ROM-specific files
        auto write_file = [&](const std::string& filename, const std::string& content) {
            fs::path path = options.output_dir / filename;
            std::ofstream file(path);
            if (!file) {
                std::cerr << "  Error: Could not write " << path << "\n";
                return false;
            }
            file << content;
            return true;
        };
        
        if (!write_file(output.header_file, output.header_content)) continue;
        if (!write_file(output.source_file, output.source_content)) continue;
        if (!write_file(output.rom_data_file, output.rom_data_content)) continue;
        
        compiled_roms.push_back({rom_name, meta});
        std::cout << "  Success\n";
    }
    
    if (compiled_roms.empty()) {
        std::cerr << "Error: No ROMs compiled successfully\n";
        return 1;
    }
    
    std::cout << "\nGenerating multi-ROM launcher files...\n";
    
    // Generate catalog
    auto catalog_content = generate_rom_catalog(compiled_roms);
    auto main_content = generate_multi_rom_main();
    auto cmake_content = generate_multi_rom_cmake(compiled_roms);
    
    // Write launcher files
    {
        std::ofstream file(options.output_dir / "rom_catalog.c");
        file << catalog_content;
    }
    {
        std::ofstream file(options.output_dir / "main.c");
        file << main_content;
    }
    {
        std::ofstream file(options.output_dir / "CMakeLists.txt");
        file << cmake_content;
    }
    
    std::cout << "\nMulti-ROM compilation complete!\n";
    std::cout << "Generated files in: " << options.output_dir << "\n\n";
    std::cout << "Build instructions:\n";
    std::cout << "  cd " << options.output_dir << "\n";
    std::cout << "  mkdir build && cd build\n";
    std::cout << "  cmake -G Ninja ..\n";
    std::cout << "  cmake --build .\n";
    std::cout << "  ./chip8_launcher\n";
    
    return 0;
}

} // namespace chip8recomp
